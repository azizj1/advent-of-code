# Day 10 - Adapter Array - [Code](10b.ts)

You're trying to power your game device, but the outlet has a rating of `0 jolts`. You
have a bunch of adapters that you can chain together to get the desired jolts.

An adapter takes some input joltage, and outputs another output joltage. These
adapters in your bag are rated with a number. E.g., `42`. An adapter rated `42`
produces an output joltage of `42`, and it can only do that if the input is **at
most 3 lower than the rating.** E.g., the input to this `42` rated adapter must
be `39`, `40`, or `41`.

Assume in your backpack you have the following adapters.

```
1
4
5
6
7
10
11
12
15
16
19
```

You could change all these adapters to go from `0` jolts to `19` jolts!

You'll notice a couple of things. For starters, some of these adapters are
unnecssary to get a max of `19` jolts. We don't need the `6` or `7` adapters,
nor do we need the `11` adapter.

What we're interested for `part B` of this problem is determing **how many
different ways they can be arranged to still get your max jolt.**

The example above has **8** different ways of getting the max voltage.

```
(0), 1, 4, 5, 6, 7, 10, 11, 12, 15, 16, 19
(0), 1, 4, 5, 6, 7, 10, 12, 15, 16, 19
(0), 1, 4, 5, 7, 10, 11, 12, 15, 16, 19
(0), 1, 4, 5, 7, 10, 12, 15, 16, 19
(0), 1, 4, 6, 7, 10, 11, 12, 15, 16, 19
(0), 1, 4, 6, 7, 10, 12, 15, 16, 19
(0), 1, 4, 7, 10, 11, 12, 15, 16, 19
(0), 1, 4, 7, 10, 12, 15, 16, 19
```

Then we have this example (adapters aren't sorted, so you'll have to sort them
first):

```
28,
33,
18,
42,
31,
14,
46,
20,
48,
47,
24,
23,
49,
45,
19,
38,
39,
11,
1,
32,
25,
35,
8,
17,
7,
9,
4,
2,
34,
10,
3,
```

which has **19,208** different ways to getting the max jolts out.

For your input, **how many different ways are there of getting the max jolts?**

## Solution

The first part in recognizing that this could be a DP solution is knowing that
this is a counting problem. The second clue is trying to play with a much
smaller input and working backwards.

- Note: if working backwards isn't apparent at first, follow the [4 step
  process](https://github.com/azizj1/leet-code/blob/master/js/src/dp/README.md).
  Come up with a recursive solution, memoize it, reverse it, and then remove the
  cache layer.

Let's work through the first example above.

```
1
4
5
6
7
10
11
12
15
16
19
```

If the adapters were just `11 12 15 16 19`, there would only be **1**
configuration, because all of these are necessary. As sooon as we get to `10`,
we can either include `11` or not because `10` can jump to `12`.

So we look at the number of ways to get to `12`, and the number of ways to get
to `11`, and add them up. Since both of those are **1**, the number of ways to
configure `10 + {originalSet}` is now **2**.

It stays that way until we get to `5` because all the ones proceeding it are
necessary in that order. If `originalSet = {6,7,10,11,12,15,16,19}`, then we can
do either `{5} + originalSet` or `{5} + (originalSet - {6})` because the set
`{6}` is optional now. Notice that `originalSet - {6}` is just `{7,10,...}`, so
we just **sum the number of ways to get to 6 and number of ways to get to 7**.
Both of those are equal to `2`, so now we have a total of **4** ways to get to
`5`.

The fibonnaci formula should be apparent now. If `g(i)` is the adapter value at
`i`, and `f(i)` is the number of ways to get to adapter `i`, then

```
f(i) = f(i + 1)
        + IF(g(i + 2) - g(i) <= 3, f(i + 2))
        + IF(g(i + 3) - g(i) <= 3, f(i + 3))
```

Just make sure to prefix the list of adapters with `0` because we ultimately
start there. This will make a differenc if you have `1` and `2` and `3` adapter,
since some of those will be optional.
